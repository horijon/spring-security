server.port=8081
#spring.jpa.hibernate.ddl-auto=update
MYSQL_HOST=spring-security-db.cr2rtsoqegh6.us-east-1.rds.amazonaws.com
MYSQL_PORT=3306
MYSQL_DATABASE_NAME=sys
spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT}/${MYSQL_DATABASE_NAME}
spring.datasource.username=admin
spring.datasource.password=Mysqldb1!
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# to log debugging of spring security
#logging.level.org.springframework.security.web.FilterChainProxy=DEBUG

# Establishing link between Resource Server (My Spring Security Project) and keycloak server. This way this project knows where is my keycloak Auth Server
# url of keycloak Auth Server from where my resource server can download the public certificate

# behind the scenes my resoruce server during the startup,
# it will download the public certificate by connecting to the authorization server.
# So the authorization server will have a private certificate or private key using which it is going to
# digitally sign all my access token, id token; and my resource server with the help of public certificate,
# it can validate if the token is tampered by someone or not, if the token is valid or not;
# this way my resource server don't have to connect with the Auth server whenever it wants
# to validate a given access token.
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://localhost:8180/realms/springsecurity-dev/protocol/openid-connect/certs


logging.level.org.springframework.web=ERROR
logging.level.com.hendisantika.springboot.swagger=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.file.name=./logs/application.log
